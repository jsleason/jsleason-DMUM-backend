import * as legacy from 'loopback-datasource-juggler';
import { DataObject, Options, AnyObject, Command, NamedParameters, PositionalParameters } from '../common-types';
import { Entity } from '../model';
import { Filter, Where } from '../query';
import { EntityCrudRepository } from './repository';
export declare namespace juggler {
    export import DataSource = legacy.DataSource;
    export import ModelBase = legacy.ModelBase;
    export import ModelBaseClass = legacy.ModelBaseClass;
    export import PersistedModel = legacy.PersistedModel;
    export import PersistedModelClass = legacy.PersistedModelClass;
}
/**
 * This is a bridge to the legacy DAO class. The function mixes DAO methods
 * into a model class and attach it to a given data source
 * @param modelClass {} Model class
 * @param ds {DataSource} Data source
 * @returns {} The new model class with DAO (CRUD) operations
 */
export declare function bindModel<T extends juggler.ModelBaseClass>(modelClass: T, ds: juggler.DataSource): T;
/**
 * Default implementation of CRUD repository using legacy juggler model
 * and data source
 */
export declare class DefaultCrudRepository<T extends Entity, ID> implements EntityCrudRepository<T, ID> {
    entityClass: typeof Entity & {
        prototype: T;
    };
    dataSource: juggler.DataSource;
    modelClass: juggler.PersistedModelClass;
    /**
     * Constructor of DefaultCrudRepository
     * @param modelClass Legacy model class
     * @param dataSource Legacy data source
     */
    constructor(entityClass: typeof Entity & {
        prototype: T;
    }, dataSource: juggler.DataSource);
    private setupPersistedModel(definition);
    create(entity: Partial<T>, options?: Options): Promise<T>;
    createAll(entities: Partial<T>[], options?: Options): Promise<T[]>;
    save(entity: T, options?: Options): Promise<T | null>;
    find(filter?: Filter, options?: Options): Promise<T[]>;
    findOne(filter?: Filter, options?: Options): Promise<T | null>;
    findById(id: ID, filter?: Filter, options?: Options): Promise<T>;
    update(entity: T, options?: Options): Promise<boolean>;
    delete(entity: T, options?: Options): Promise<boolean>;
    updateAll(data: Partial<T>, where?: Where, options?: Options): Promise<number>;
    updateById(id: ID, data: Partial<T>, options?: Options): Promise<boolean>;
    replaceById(id: ID, data: Partial<T>, options?: Options): Promise<boolean>;
    deleteAll(where?: Where, options?: Options): Promise<number>;
    deleteById(id: ID, options?: Options): Promise<boolean>;
    count(where?: Where, options?: Options): Promise<number>;
    exists(id: ID, options?: Options): Promise<boolean>;
    execute(command: Command, parameters: NamedParameters | PositionalParameters, options?: Options): Promise<AnyObject>;
    protected toEntity(model: DataObject<T>): T;
    protected toEntities(models: DataObject<T>[]): T[];
}
